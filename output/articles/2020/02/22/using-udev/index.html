<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Mats Melander" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="Linux, Technologies, " />

<meta property="og:title" content="Using udev "/>
<meta property="og:url" content="https://wlog.viltstigen.se/articles/2020/02/22/using-udev/" />
<meta property="og:description" content="Introduction udev, for user space /dev, is a device manager for Linux. It manages all nodes in the /dev directory as well as managing events when devices are added or removed. For my purposes, I want to control consistent and permanent naming for specific USB devices I add to a …" />
<meta property="og:site_name" content="Wolfblog" />
<meta property="og:article:author" content="Mats Melander" />
<meta property="og:article:published_time" content="2020-02-22T00:00:00+01:00" />
<meta name="twitter:title" content="Using udev ">
<meta name="twitter:description" content="Introduction udev, for user space /dev, is a device manager for Linux. It manages all nodes in the /dev directory as well as managing events when devices are added or removed. For my purposes, I want to control consistent and permanent naming for specific USB devices I add to a …">

        <title>Using udev  · Wolfblog
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="https://wlog.viltstigen.se/theme/css/elegant.prod.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://wlog.viltstigen.se/theme/css/custom.css" media="screen">

        <link href="https://wlog.viltstigen.se/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Wolfblog - Full Atom Feed" />
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-97010459-1', 'auto');
    ga('send', 'pageview');
</script>


    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="https://wlog.viltstigen.se/"><span class=site-name>Wolfblog</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       https://wlog.viltstigen.se
                                    >Home</a>
                                </li>
                                <li ><a href="https://wlog.viltstigen.se/pages/about/">About</a></li>
                                <li ><a href="https://wlog.viltstigen.se/categories.html">Categories</a></li>
                                <li ><a href="https://wlog.viltstigen.se/tags.html">Tags</a></li>
                                <li ><a href="https://wlog.viltstigen.se/archives.html">Archives</a></li>
                                <li><form class="navbar-search" action="https://wlog.viltstigen.se/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="https://wlog.viltstigen.se/articles/2020/02/22/using-udev/">
                Using udev
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <h1>Introduction</h1>
<p><strong>udev</strong>, for <strong>user</strong> space <strong>/dev</strong>, is a device manager for Linux. It manages all nodes in the <strong>/dev</strong> directory as
well as managing events when devices are added or removed.</p>
<p>For my purposes, I want to control consistent and permanent naming for specific USB devices I add to a raspberry.</p>
<h2>udev</h2>
<p>To have a permanent name in the <strong>/dev</strong> directory, such as <strong>/dev/ttyEMC</strong>, rather than <strong>/dev/ttyUSB0</strong> which may vary 
over time to <strong>/dev/ttyUSB1</strong>, a <strong>udev rules</strong> file is available and soft linked to the <code>/etc/udev/rules.d</code> directory</p>
<div class="highlight"><pre><span></span><span class="err">sudo ln -s /home/pi/app/EMC/py/10-EMC.rules /etc/udev/rules.d/10-EMC.rules</span>
</pre></div>


<p>The syntax in the file follows the description at <a href="https://wiki.archlinux.org/index.php/Udev">https://wiki.archlinux.org/index.php/Udev</a></p>
<p>Some handy commands are below to find out the values to the rules parameters.</p>
<div class="highlight"><pre><span></span>$ udevadm info -a -n /dev/ttyUSB0
$ udevadm info -a -p <span class="k">$(</span>udevadm info -q path -n /dev/ttyUSB0<span class="k">)</span>
$ sudo udevadm <span class="nb">test</span> <span class="k">$(</span>udevadm info -q path -n /dev/ttyUSB0<span class="k">)</span> <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
</pre></div>


<p>The last command will test and trigger the new rule, thus creating <code>/dev/ttyEMC</code>.
See <a href="http://www.reactivated.net/writing_udev_rules.html">http://www.reactivated.net/writing_udev_rules.html</a></p>
<h1>Additional udev</h1>
<p>By <a href="http://ubuntuforums.org/showthread.php?t=901891">http://ubuntuforums.org/showthread.php?t=901891</a>, see end of thread</p>
<div class="highlight"><pre><span></span>Here is an explanation of how udev and hotplug works:

========================================
Linux specific installation information
by Linus Walleij
covering libusb 0.1.10
========================================

Since libusb is accessing the raw device nodes exported by the kernel in order to identify connected USB busses, functions and such, it needs to find these nodes. During the history of the Linux kernel, the placement and the way of accessing these nodes have changed.

This placement is closely related to hotplugging: i.e. addition and removal of USB functions at runtime.


## Most current solution: use udev


The latest and greatest way of managing hotplugged (and cold-plugged) devices under Linux is called &quot;udev&quot;. This is a development of the older &quot;hotplug&quot; system (see below).

When a device is connected, the kernel will call the program /sbin/udev in order to create a device node in the /dev/ file hirerarchy. It will also remove devices from this hierarchy when they are unplugged.

Traditionally, all devices plugged into a Linux system are expected to have a kernel device driver, or to load one on-the-fly when a new device is connected. Libusb cannot use these device drivers, instead it attempts to access the raw device nodes from user mode, not as a kernel module.

In order for libusb to find the device node, it needs to locate it in the /dev filesystem. The recommended way to let udev create nodes in the /dev filesystem is to add a udev rule like the following into some foo.rules file inside the /etc/udev/rules.d/ directory:

# usbfs-like devices
SUBSYSTEM==&quot;usb_device&quot;, PROGRAM=&quot;/bin/sh -c &#39;K=%k; K=$${K#usbdev}; \ printf bus/usb/%%03i/%%03i $${K%%%%.*} $${K#*.}&#39;&quot;, \ NAME=&quot;%c&quot;

This layout is used by for example the Debian distribution and Fedora Core. This rule creates a device tree identical to the earlier /proc/bus/usb/ tree, but under /dev/bus/usb/ instead. If this device tree exists, libusb will default to use it. It will look like this:

/dev
/bus
   /usb
     /001
       /001
       /002
       /003
    /002
       /001
       /002
       ...

However notice that the permissions on the nodes will be default
permissions: often this means they are only accessible for writing by the root user, whereas non-root users often can access it read-only.

The way of controlling access to a device node differs between systems, but a typical way of complementing udev rules with apropriate permissions is to use PAM (pluggable Authentication Modules), with some sort of configuration under /etc/security/.
(For details on this, see below.)

The use of /dev nodes is also different from the old usbfs solution in that it enables the use of ACL:s (Access Control
Lists) to control access for the USB device nodes. ACL:s could not be used on the /proc filesystem.

A less good alternative that may however be useful for debugging would be to supply the argument MODE=&quot;666&quot; to the above udev rule, or, slightly better, to tag on:

MODE=&quot;660&quot;, GROUP=&quot;foo&quot;

where &quot;foo&quot; is a group of users (e.g. desktop users) that need to access the device in read/write mode.

If libusb cannot find a device hierarchy below /dev/bus/usb/ (as is the case if you are not using udev, or not using it with the above rule), it will fall back on using /proc/bus/usb/ instead.

Additionally, you may want to trigger unique actions for your device at the same time. To do this, create a rules file /etc/udev/rules.d/bar.rules with these lines:

SUBSYSTEM==&quot;usb_device&quot;, ACTION==&quot;add&quot;, SYSFS{idVendor}==&quot;1234&quot;, \ SYSFS{idProduct}==&quot;4321&quot;

At the end of this line you can then tag on any device-specific actions for device 1234/4321, for example:

MODE=&quot;660&quot;, GROUP=&quot;baz&quot;   to set mode and group
RUN=&quot;/usr/local/bin/baz&quot;  to run a script on plug-in
SYMLINK+=&quot;foo&quot;            to create a symlink device node with
                         this name in /dev

You can read more about udev in its own documentation.


Permissions setting with PAM
============================

In addition to the udev rule for creating the device node you will want to change the permissions on the new node, unless it defaults to something that is globally writeable and readable.
Making anything that is plugged in on the USB bus writeable and readable by ALL users is typically a bad idea, because what you most typically want to do is to make it writeable and readable for the console user, i.e. the person that happens to sit behind the screen and keyboard of this very computer.

Managing this by groups is a bit kludgy: it means you set up a group for all console users and add all users that may use the console to this group. This also mean that one user that is a member of this group could be at the console plugging his USB keydrive in, while another user of the same group is logged in remotely, and making a blank copy of the same keydrive at the same time, for example.

Since Linux is used in a strict multi-user context, this has to be solved: give permissions to hotplugged devices only to the console user.

Fedora Core 5 and later does this by using PAM. Whenever something happens in udev, PAM is called to modify the permissions on anything that appeared in the file system in accordance to a set of security rules.

The trick is to create a symbolic link for your new device, then let PAM match the name of this link and change the permissions of it. For example, in /etc/udev/rules.d/foo.rules you write:

SUBSYSTEM==&quot;usb_device&quot;, ACTION==&quot;add&quot;, SYSFS{idVendor}==&quot;1234&quot;, \ SYSFS{idProduct}==&quot;4321&quot;, SYMLINK+=&quot;foo-%k&quot;

This will create a symlink named &quot;/dev/foo-nn&quot; where nn is some unique number for each added device matching this VID and PID.
You then set up PAM console rules in accordance, by adding a /etc/security/console.perms.d/foo.perms containing:

<span class="nt">&lt;foo&gt;</span>=/dev/foo*
<span class="nt">&lt;console&gt;</span> 0600 <span class="nt">&lt;foo&gt;</span> 0600 root

This instructs PAM to give the console user (and root) read and write permissions to the new symlink, whenever it appears. The permission change on the symlink will then fall through to the new device node.


Previous solution: use hotplug
==============================

Before udev another system, generally considered less elegant, known simply as &quot;hotplug&quot; was used. In this case the program /sbin/hotplug would be called whenever devices were connected or removed from the system, and the corresponding configuration lives in /etc/hotplug/.

With hotplug not using udev at the same time, all devices are accessed using the usbfs hierarchy below /proc/bus/usb/. Again, thishttp://mihd.net/y7w20q will be used by libusb, since libusb does not use any device drivers. The hierarchy will look like this:

/proc
/bus
   /usb
     /001
       /001
       /002
       /003
    /002
       /001
       /002
       ...

When USB devices are plugged in, their corresponding device node is created in /proc/bus/usb/ by the kernel, without any external program intervention (as is the case with udev).

However, to correct the permissions on these device nodes, if your device requires anything else than read access, you need to supply a script in /etc/hotplug/usb/ that detects your device and change its permissions, for example this /etc/hotplug/usb/foo.usermap

# Foo device with VID=1234 and PID=4321
bar 0x0003 0x1234 0x4321 0x0000 0x0000 0x00 0x00 0x00 0x00 0x00 0x00 0x00000000

(All this need to be in one line.)

The first string &quot;bar&quot; points out the name of a script placed in /etc/hotplug/usb/bar, with for example the following contents:

#!/bin/bash
if [ &quot;<span class="cp">${</span><span class="n">ACTION</span><span class="cp">}</span>&quot; = &quot;add&quot; ] <span class="err">&amp;&amp;</span> [ -f &quot;<span class="cp">${</span><span class="n">DEVICE</span><span class="cp">}</span>&quot; ] then chgrp baz &quot;<span class="cp">${</span><span class="n">DEVICE</span><span class="cp">}</span>&quot;
chmod 660 &quot;<span class="cp">${</span><span class="n">DEVICE</span><span class="cp">}</span>&quot;
fi

to let users in the group &quot;baz&quot; access the device for reading and writing. There exist solutions similar to the PAM permission change for hotplug, but they are all kind of hackish.

You can read more about hotplug and its usermaps in the hotplug documentation.
</pre></div>


             


<script src="https://wlog.viltstigen.se/theme/applause-button/applause-button.js"></script>
<div class="applause_button">
    <applause-button url=https://wlog.viltstigen.se/articles/2020/02/22/using-udev/> </applause-button>
</div>

 
            
            
            






            <hr/>
        </div>
        <section id="article-sidebar" class="span2">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2020-02-22T00:00:00+01:00">Feb 22, 2020</time>
            <h4>Category</h4>
            <a class="category-link" href="https://wlog.viltstigen.se/categories.html#technologies-ref">Technologies</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://wlog.viltstigen.se/tags.html#linux-ref">Linux
                    <span>2</span>
</a></li>
            </ul>
<h4>Contact</h4>
<div id="sidebar-social-link">
    <a href="mailto:mats.melander@gmail.com" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="Mail" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#328cff"/><path d="m250 186c-46 0-69 35-69 74 0 44 29 72 68 72 43 0 73-32 73-75 0-44-34-71-72-71zm-1-37c30 0 57 13 77 33 0-22 35-22 35 1v150c-1 10 10 16 16 9 25-25 54-128-14-187-64-56-149-47-195-15-48 33-79 107-49 175 33 76 126 99 182 76 28-12 41 26 12 39-45 19-168 17-225-82-38-68-36-185 67-248 78-46 182-33 244 32 66 69 62 197-2 246-28 23-71 1-71-32v-11c-20 20-47 32-77 32-57 0-108-51-108-108 0-58 51-110 108-110" fill="#fff"/></svg>
    </a>
    <a href="https://github.com/wolfrax" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
    </a>
</div>
            





            





        </section>
</div>
</article>
                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>